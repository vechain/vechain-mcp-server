name: Publish Discourse MCP Docker image

on:
  workflow_call:
    inputs:
      image_tag:
        description: 'Tag for the Docker image (defaults to git SHA)'
        required: false
        type: string
        default: ''
      set_latest:
        description: 'Also tag as latest'
        required: false
        type: boolean
        default: false
  workflow_dispatch:
  push:
    paths:
      - 'discourse-mcp/**'
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

env:
  ECR_REPOSITORY: discourse-mcp

jobs:
  determine-tag:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Determine image tag
        id: tag
        run: |
          if [ -n "${{ inputs.image_tag }}" ]; then
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  build:
    needs: [determine-tag]
    strategy:
      fail-fast: false
      matrix:
        include:
          - runs_on: ubuntu-latest
            platform: linux/amd64
            arch_suffix: amd64
          - runs_on: ubuntu-latest
            platform: linux/arm64
            arch_suffix: arm64
    runs-on: ${{ matrix.runs_on }}
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$ECR_REPOSITORY" >/dev/null

      - name: Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push (${{ matrix.platform }})
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./discourse-mcp
          push: true
          platforms: ${{ matrix.platform }}
          outputs: |
            type=registry,name=ghcr.io/${{ github.repository_owner }}/discourse-mcp:${{ needs.determine-tag.outputs.tag }}-${{ matrix.arch_suffix }}
            type=registry,name=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.determine-tag.outputs.tag }}-${{ matrix.arch_suffix }}
          cache-from: type=gha,scope=discourse-${{ github.ref_name }}-${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=discourse-${{ github.ref_name }}-${{ matrix.platform }}

  merge-manifest:
    needs: [build, determine-tag]
    runs-on: ubuntu-latest
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push manifest lists
        shell: bash
        env:
          GH_IMAGE: ghcr.io/${{ github.repository_owner }}/discourse-mcp
          ECR_IMAGE: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          TAG: ${{ needs.determine-tag.outputs.tag }}
          SET_LATEST: ${{ inputs.set_latest }}
        run: |
          set -euo pipefail
          for image in "${GH_IMAGE}" "${ECR_IMAGE}"; do
            [ -z "$image" ] && continue
            TAG_ARGS="-t ${image}:${TAG}"
            if [ "${SET_LATEST}" = "true" ]; then
              TAG_ARGS="${TAG_ARGS} -t ${image}:latest"
            fi
            docker buildx imagetools create \
              ${TAG_ARGS} \
              "${image}:${TAG}-amd64" \
              "${image}:${TAG}-arm64"
          done

      - name: Cleanup arch tags in GHCR
        shell: bash
        env:
          OWNER: ${{ github.repository_owner }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.determine-tag.outputs.tag }}
        run: |
          set -euo pipefail
          PACKAGE_NAME="discourse-mcp"
          API_BASE="https://api.github.com"
          LIST_URL="${API_BASE}/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions?per_page=100"
          DELETE_BASE="${API_BASE}/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions"
          RESP=$(curl -fsS -H "Authorization: Bearer ${GH_TOKEN}" \
                 -H "Accept: application/vnd.github+json" \
                 "$LIST_URL" || true)
          [ -z "$RESP" ] && exit 0
          IDS=$(echo "$RESP" | jq -r --arg t1 "${TAG}-amd64" --arg t2 "${TAG}-arm64" '.[] | select((.metadata.container.tags // []) | index($t1) or index($t2)) | .id')
          for id in $IDS; do
            curl -fsS -X DELETE -H "Authorization: Bearer ${GH_TOKEN}" \
                 -H "Accept: application/vnd.github+json" \
                 "${DELETE_BASE}/${id}" || true
          done

      - name: Cleanup arch tags in ECR
        shell: bash
        env:
          TAG: ${{ needs.determine-tag.outputs.tag }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
        run: |
          set -euo pipefail
          TARGET1="${TAG}-amd64"
          TARGET2="${TAG}-arm64"

          delete_targets() {
            local tag
            for tag in "$@"; do
              for attempt in $(seq 1 10); do
                echo "[ECR] Resolving digest for tag: ${tag} (attempt ${attempt})"
                DETAILS=$(aws ecr describe-images --repository-name "$ECR_REPOSITORY" --output json || true)
                DIGEST=$(echo "$DETAILS" | jq -r --arg tag "$tag" '
                  .imageDetails[]? | select(.imageTags // [] | index($tag)) | .imageDigest // empty' | head -n1)
                if [ -z "${DIGEST:-}" ]; then
                  echo "[ECR] Tag ${tag} not found in describe-images (may be eventually consistent)."
                else
                  echo "[ECR] Deleting by digest ${DIGEST} for tag ${tag}"
                  aws ecr batch-delete-image --repository-name "$ECR_REPOSITORY" \
                    --image-ids imageDigest="${DIGEST}" >/dev/null 2>&1 || true
                fi

                if ! aws ecr describe-images --repository-name "$ECR_REPOSITORY" \
                     --image-ids imageTag="${tag}" >/dev/null 2>&1; then
                  echo "[ECR] ${tag} removed"
                  break
                fi
                sleep 5
              done
            done
          }

          delete_targets "$TARGET1" "$TARGET2"

